## Setups

### Loading packages and custom functions

```{r}
# loading packages
# devtools::install_github("thomasp85/patchwork")
pacman::p_load(tidyverse, # tidy family and related pacakges below
               kableExtra, 
               gridExtra, # may not use this
               purrr,
               magrittr, # extending piping
               pander,   # nice tables
               metafor,  # package for meta-analysis
               MCMCglmm,  # Bayeisan mixed model package
               ggbeeswarm, # making bee-swarm plots possible
               plotly,     # interactive plots using ggplot2
               MuMIn,  # multi-model inference
               lme4,   # lmm & glmm (models)
               broom.mixed, # getting estimates from lmer + glmer objects
               performance, # getting R2 from lmer + glmer objects
               png,         # reading png files
               grid,        # graphic layout manipulation
               patchwork    # putting ggplots together - you need to install via devtool
               #lmerTest   # more functions for lme4
               #mi,      # missing data analysis
               #betareg   # dependance of the above
)
```

#### Custom functions

We have 5 custom functions named : `p_to_Zr()`,`I2()`, `R2()`, `get_est()`, `get_pred()`, and `cont_gen()`, all of which are used later (see below for their functionality) and the code are included here. 

```{r}
# coustm functions

#' Title: getting Zr and its sampling variance from p value 
#'
#' @param data: data frame 
#' @param pval: p value
#' @param N: sample size (N: the number of species ) and the degrees of freedom df = N - 2
#'
#' @return
#' @export
#'
#' @examples
p_to_Zr <- function(data, pval, N) {
  
  # turning them into strings
  pval <- data[[deparse(substitute(pval))]]
  N <- data[[deparse(substitute(N))]]
  
  # getting t values 
  tval<- -qt(pval, N - 2) 
  rval <- tval / sqrt((tval^2) + (N - 2))
  
  # define Zr function
  # Zr <- 0.5*(log(1 + rval) - log(1 - rval)); the same as below
  # r <-tanh(Zr) # turning Zr to r
  Zr <- atanh(rval)
  
  # getting Var(Zr)
  VZr <- 1 / (N - 3)
  
  # putting all together
  Zrs <- tibble(rval, Zr, VZr)
  data <- bind_cols(data, Zrs)
}

# coverting back Zr to r
# Just use "psych" pacakge - fisherz2r(z) - <http://personality-project.org/r/psych/help/fisherz.html>
# or this will do : r to Zr is tanh(r)!!

# Functions for processing


# General modeling functions 
# Functions for I2

#' Title Function to obtain total and separate I2 from multilevel-meta-analytic model
#'
#' @param model 
#' @param method 
#'
#' @return
#' @export
#'
#' @examples
I2 <- function(model, method = c("Wolfgang", "Shinichi")){
  
  ## evaluate choices
  method <- match.arg(method)
  
  # Wolfgang's method
  if(method == "Wolfgang"){
    W <- solve(model$V) 
    X <- model.matrix(model)
    P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
    I2_total <- sum(model$sigma2) / (sum(model$sigma2) + (model$k - model$p) / sum(diag(P)))
    I2_each  <- model$sigma2 / (sum(model$sigma2) + (model$k - model$p) / sum(diag(P)))
    names(I2_each) = paste0("I2_", model$s.names)
    
    # putting all together
    I2s <- c(I2_total = I2_total, I2_each)
    
    # or my way
  } else {
    # sigma2_v = typical sampling error variance
    sigma2_v <- sum(1/model$vi) * (model$k-1) / (sum(1/model$vi)^2 - sum((1/model$vi)^2)) 
    I2_total <- sum(model$sigma2) / (sum(model$sigma2) + sigma2_v) #s^2_t = total variance
    I2_each  <- model$sigma2 / (sum(model$sigma2) + sigma2_v)
    names(I2_each) = paste0("I2_", model$s.names)
    
    # putting all together
    I2s <- c(I2_total = I2_total, I2_each)
  }
  return(I2s)
}

I2_Hamza <- function(model){
W <- diag(1/model$vi)
X <- model.matrix(model)
P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
I2_total <- 100 * sum(model$sigma2) / (sum(model$sigma2) + (model$k-model$p)/sum(diag(P)))
}


# test <- dataset$fit4.1[[3]]
# I2(test, method = "Wolfgang")
# I2(test, method = "Shinichi")


#' Title: R2 based on Nakagawa & Schielzeth 2013
#'
#' @param model 
#'
#' @return
#' @export
#'
#' @examples
R2 <- function(model){
  warning("Conditional R2 is not meaningful and the same as marginal R2\n")
  
  # fixed effect variance
  fix <- var(as.numeric(as.vector(model$b) %*% t(as.matrix(model$X))))
  
  # marginal
  R2m <- fix / (fix + sum(model$sigma2))
  R2
  #Rm <- round(100*R2m, 3)
  
  # conditional
  R2c <- (fix + sum(model$sigma2) - model$sigma2[length(model$sigma2)]) / 
    (fix + sum(model$sigma2))
  
  R2s <- c(R2_marginal = R2m, R2_coditional = R2c)
  return(R2s)
}


#' Title: the function to get estimates from rma objects (metafor)
#'
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_est <- function (model, mod = " ") {
  
  name <- as.factor(str_replace(row.names(model$beta), mod, ""))
  estimate <- as.numeric(model$beta)
  lowerCL <- model$ci.lb
  upperCL <- model$ci.ub 
  
  table <- tibble(name = name, estimate = estimate, lowerCL = lowerCL, upperCL = upperCL)
}


#' Title: the function to get prediction intervals (crediblity intervals) from rma objects (metafor)
#'
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_pred <- function (model, mod = " ") {
  name <- as.factor(str_replace(row.names(model$beta), mod, ""))
  len <- length(name)
  
  if(len != 1){
  newdata <- matrix(NA, ncol = len, nrow = len)
  for(i in 1:len) {
    # getting the position of unique case from X (design matrix)
    pos <- which(model$X[,i] == 1)[[1]]
    newdata[, i] <- model$X[pos,]
    }
  pred <- predict.rma(model, newmods = newdata)
  }
  else {
    pred <- predict.rma(model)
    }
  lowerPR <- pred$cr.lb
  upperPR <- pred$cr.ub 
  
  table <- tibble(name = name, lowerPR = lowerPR, upperPR = upperPR)
}

#Here are links for how to do confidence regions for rma.mv regression lines
#https://www.rdocumentation.org/packages/metafor/versions/1.9-9/topics/predict.rma
#https://stackoverflow.com/questions/50804464/out-of-sample-prediction-for-rma-object-in-metafor


#' Title: Contrast name geneator
#'
#' @param name: a vector of character strings
cont_gen <- function (name) {
  combination <- combn(name,2)
  name_dat <- t(combination)
  names <- paste(name_dat[ ,1], name_dat[, 2], sep = "-")
  return(names)
}
```

```{r load packages, include=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(openxlsx)  
library(knitr)
library(metafor)
library(ggplot2)
library(readxl)
library(orchaRd)
library(patchwork)
library(tidyverse)
#Install miktex and then run this to knit a pdf file
#install.packages('tinytex')
#tinytex::install_tinytex()
```



```{r, include = FALSE}
#Load Data

#Import data
ALL_TRAITS <- read_excel("../data/ALL_TRAITS.xlsx")

#Assigning Control Id's by combining Paper ID and Shared_Control
ALL_TRAITS$Control_ID <- paste(ALL_TRAITS$Paper_ID, ALL_TRAITS$Shared_Control)
unique(ALL_TRAITS$Cohort_ID) %>% length()
```


## Calculating Effect Sizes lnRR

We calculated our effect sizes (log response ratio lnRR) for our complete data set (all traits).
```{r, include = FALSE}

Effect_Size_All_Traits <- escalc(measure="ROM", m1i=Mean_Treatment, sd1i=SD_Treatment, n1i=Sample_Size_n_Treatment, m2i=Mean_Control, sd2i=SD_Control, n2i=Sample_Size_n_Control, data=ALL_TRAITS)

hist(Effect_Size_All_Traits$yi)
hist(log(Effect_Size_All_Traits$vi))

#Adding Effect Size ID's
ES_ID <- factor(1:dim(Effect_Size_All_Traits)[1])
Effect_Size_All_Traits$ES_ID <-ES_ID

#Converting into factors

Effect_Size_All_Traits$Trait <- factor(Effect_Size_All_Traits$Trait)
Effect_Size_All_Traits$Exposure_Type <- factor(Effect_Size_All_Traits$Exposure_Type)
Effect_Size_All_Traits$Sex <- factor(Effect_Size_All_Traits$Sex)
Effect_Size_All_Traits$Generation <- factor(Effect_Size_All_Traits$Generation)
Effect_Size_All_Traits$Cohort_ID <- factor(Effect_Size_All_Traits$Cohort_ID)
Effect_Size_All_Traits$Paper_ID <- factor(Effect_Size_All_Traits$Paper_ID)
Effect_Size_All_Traits$Rodent_type <- factor(Effect_Size_All_Traits$Rodent_type)
Effect_Size_All_Traits$F2_Diet_at_measurement <- factor(Effect_Size_All_Traits$F2_Diet_at_measurement)
Effect_Size_All_Traits$Strain <- factor(Effect_Size_All_Traits$Strain)
Effect_Size_All_Traits$F0_Parent_Exposed <- factor(Effect_Size_All_Traits$F0_Parent_Exposed)

Effect_Size_All_Traits$Sex <- gsub("Both ", "Both", Effect_Size_All_Traits$Sex)

#Subsetting by One off and Multigenerational

MG_ALL <- subset(Effect_Size_All_Traits, Effect_Size_All_Traits$Exposure_Type == "Multigenerational")

OF_ALL <- subset(Effect_Size_All_Traits, Effect_Size_All_Traits$Exposure_Type == "One off")

write.csv(Effect_Size_All_Traits, file ="Effect_Size_All_Traits.csv")

save(Effect_Size_All_Traits, file = "Effect_Size_All_Traits.RData") #DOUBLE CHECK THIS IS CORRECT FOR ALL TRAITS!!!
```

### Calculating effect sizes (lnCVR)

We calculated our effect sizes (lnCVR) for our complete data set (all traits).
```{r, include = FALSE}

Effect_Size_All_Traits_lnCVR <- escalc(measure="CVR", m1i=Mean_Treatment, sd1i=SD_Treatment, n1i=Sample_Size_n_Treatment, m2i=Mean_Control, sd2i=SD_Control, n2i=Sample_Size_n_Control, data=ALL_TRAITS)

#Adding Effect Size ID's
ES_ID <- factor(1:dim(Effect_Size_All_Traits_lnCVR)[1])
Effect_Size_All_Traits_lnCVR$ES_ID <-ES_ID

#Converting into factors

Effect_Size_All_Traits_lnCVR$Trait <- factor(Effect_Size_All_Traits_lnCVR$Trait)
Effect_Size_All_Traits_lnCVR$Exposure_Type <- factor(Effect_Size_All_Traits_lnCVR$Exposure_Type)
Effect_Size_All_Traits_lnCVR$Sex <- factor(Effect_Size_All_Traits_lnCVR$Sex)
Effect_Size_All_Traits_lnCVR$Generation <- factor(Effect_Size_All_Traits_lnCVR$Generation)
Effect_Size_All_Traits_lnCVR$Cohort_ID <- factor(Effect_Size_All_Traits_lnCVR$Cohort_ID)
Effect_Size_All_Traits_lnCVR$Paper_ID <- factor(Effect_Size_All_Traits_lnCVR$Paper_ID)
Effect_Size_All_Traits_lnCVR$Rodent_type <- factor(Effect_Size_All_Traits_lnCVR$Rodent_type)
Effect_Size_All_Traits_lnCVR$F2_Diet_at_measurement <- factor(Effect_Size_All_Traits_lnCVR$F2_Diet_at_measurement)
Effect_Size_All_Traits_lnCVR$Strain <- factor(Effect_Size_All_Traits_lnCVR$Strain)
Effect_Size_All_Traits_lnCVR$F0_Parent_Exposed <- factor(Effect_Size_All_Traits_lnCVR$F0_Parent_Exposed)

Effect_Size_All_Traits_lnCVR$Sex <- gsub("Both ", "Both", Effect_Size_All_Traits_lnCVR$Sex)

#Subsetting into MG and OF
MG_ALL_lnCVR <- subset(Effect_Size_All_Traits_lnCVR, Effect_Size_All_Traits_lnCVR$Exposure_Type == "Multigenerational")

OF_ALL_lnCVR <- subset(Effect_Size_All_Traits_lnCVR, Effect_Size_All_Traits_lnCVR$Exposure_Type == "One off")

save(Effect_Size_All_Traits_lnCVR, file = "Effect_Size_All_Traits_lnCVR.RData")

```

